/*
 * This file is part of spyNet Camera, the Android IP camera
 *
 * Copyright (C) 2016-2017 Paolo Dematteis
 *
 * spyNet Camera is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * spyNet Camera is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Paolo Dematteis - spynet314@gmail.com
 */

package com.spynet.camera.network.Angelcam.API;

import com.spynet.camera.network.TCPConnection;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InvalidObjectException;

/**
 * Defines an Arrow protocol message.<br>
 * All Arrow Messages exchanged between Arrow Clients and Arrow Services have binary headers,
 * they MUST use the network byte order.
 */
public class Message {

    protected final int mVersion;       // Major version of the protocol
    protected final int mServiceID;     // Service ID
    protected final int mSessionID;     // Session ID identifying a connection to a local service
    protected byte[] mBody;             // Message body

    /**
     * Reads a Message object from an active connection.
     *
     * @param connection the connection from which to read the message
     * @return the new Message object or null on end of stream (server socket closed)
     * @throws IOException if an error occurs while reading from {@code connection}
     *                     or if the read data is not valid
     */
    public static Message fromStream(TCPConnection connection) throws IOException {

        int version, serviceID, sessionID, bodySize;
        int read;
        byte[] body;

        // Read the header
        byte[] hdr = new byte[11];
        read = connection.read(hdr);
        if (read == -1)
            return null;
        if (read < hdr.length)
            throw new InvalidObjectException("invalid message header");
        // Parse the header
        version = hdr[0];
        serviceID = ((hdr[1] & 0xff) << 8) | (hdr[2] & 0xff);
        sessionID = ((hdr[4] & 0xff) << 16) | ((hdr[5] & 0xff) << 8) | (hdr[6] & 0xff);
        bodySize = ((hdr[7] & 0xff) << 24) | ((hdr[8] & 0xff) << 16) | ((hdr[9] & 0xff) << 8) | (hdr[10] & 0xff);
        // Read the body
        body = new byte[bodySize];
        if (connection.read(body) < body.length)
            throw new InvalidObjectException("invalid message body");
        // Create and return a new Message
        return new Message(version, serviceID, sessionID, body);
    }

    /**
     * Creates a new Message object.
     *
     * @param serviceID the service ID
     * @param sessionID the session ID identifying a connection to a local service,
     *                  it is generated by the Arrow Service
     */
    public Message(int serviceID, int sessionID) {
        mVersion = AngelcamAPI.VERSION;
        mServiceID = serviceID;
        mSessionID = sessionID;
    }

    /**
     * Creates a new Message object.
     *
     * @param version   major version of the protocol
     * @param serviceID the service ID
     * @param sessionID the session ID identifying a connection to a local service,
     *                  it is generated by the Arrow Service
     * @param body      the message body
     */
    public Message(int version, int serviceID, int sessionID, byte[] body) {
        mVersion = version;
        mServiceID = serviceID;
        mSessionID = sessionID;
        mBody = body;
    }

    /**
     * @return this message's current contents as a byte array
     */
    public byte[] toByteArray() throws IOException {

        ByteArrayOutputStream buffer = new ByteArrayOutputStream();

        // version - unsigned integer
        buffer.write(mVersion);
        // svc_id - unsigned integer
        buffer.write(mServiceID >> 8);
        buffer.write(mServiceID);
        // reserved
        buffer.write(0);
        // session_id - unsigned integer
        buffer.write(mSessionID >> 16);
        buffer.write(mSessionID >> 8);
        buffer.write(mSessionID);
        // body_size - unsigned integer
        int bodySize = mBody != null ? mBody.length : 0;
        buffer.write(bodySize >> 24);
        buffer.write(bodySize >> 16);
        buffer.write(bodySize >> 8);
        buffer.write(bodySize);
        // body
        if (mBody != null) buffer.write(mBody);

        return buffer.toByteArray();
    }

    /**
     * @return the major version of the protocol
     */
    public int getVersion() {
        return mVersion;
    }

    /**
     * @return the service ID
     */
    public int getServiceID() {
        return mServiceID;
    }

    /**
     * @return the session ID identifying a connection to a local service
     */
    public int getSessionID() {
        return mSessionID;
    }

    /**
     * @return the message body
     */
    public byte[] getBody() {
        return mBody;
    }
}
